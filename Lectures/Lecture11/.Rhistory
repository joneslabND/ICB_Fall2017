y=2
f(y)
w=12
f<-function(y){
d=8
h<-function(){
return(d*(w+y))
}
environment(h)
return(h())
}
y=2
f(y)
rm(list=ls())
w=12
f<-function(y){
d=8
h<-function(){
return(d*(w+y))
}
print(environment(h))
return(h())
}
y=2
f(y)
# scoping example
rm(list=ls())
w=12
f<-function(y){
d=8
print(environment(h))
h<-function(){
return(d*(w+y))
}
return(h())
}
y=2
f(y)
environment(w)
environment(y)
environment(f)
?environment
?optim
SSEcalc<-function(p,x,y){
b=p[1]
m=p[2]
yhat=m*x+b
errors=y-yhat
SSE=sum(errors*errors)
return(SSE)
}
x=sample(1:25,10)
y=rnorm(10,x*2+1,sd=0.0000001)
y=rnorm(10,x*2+1,sd=5)
plot(x,y)
guess=c("b"=1,"m"=1)
modelFit=optim(guess,SSEcalc,x=x,y=y)
abline(a=modelFit$par[1],b=modelFit$par[2])
modelFit
rm(list=ls())
namesM1=c('Katherine B.','Brittni','Caitlin','Timothy','Whitney','Colin','Patrick','Benjamin','Chinedu','Erin','Katherine O.','Carly','Jody','Devin','Brooke','Yingying','Diana')
namesM2=c('Katherine B.','Brittni','Caitlin','Timothy','Whitney','Mauna','Colin','Benjamin','Chinedu','Erin','Katherine O.','Carly','Jody','Devin','Brooke')
namesM3=c('Katherine B.','Brittni','Caitlin','Timothy','Whitney','Mauna','Colin','Benjamin','Chinedu','Erin','Katherine O.','Carly','Jody','Devin','Brooke','Martha','Meredith','Brandon','Rachel','Carmella')
length(namesM1)
length(namesM2)
length(namesM3)
groups=matrix(sample(c(namesM1,rep(NA,3)),length(namesM1)+3),nrow=5,ncol=4)
colnames(groups)=paste("Group ",1:4)
groups
groups
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library(ggplot2)
dev.new()
par(mfrow(c(2,1)))
par(mfrow=c(2,1)))
par(mfrow=c(2,1))
plot(1:5,1:5)
plot(1:5,1:5)
plot(1:5,1:5)
rm(list=ls())
setwd("/Users/stuartjones/Documents/Research/People/Students/current/CaceresVelazquez_Hildamarie/scripts_help/BACTgrowthefficiency")
library(deSolve)
abs=read.table("GrowthRate_input_raw_labiso.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
biomass=read.table("Data_C_mg_all.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
co2=read.table("summData_allruns_mean_umol.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
co2except=read.table("headspaceExceptions_3-22-17.txt",header=TRUE,stringsAsFactors=FALSE)
head(co2except)
head(co2)
head(abs)
dim(abs)
colnames(abs)
rownames(abs)
head(bioams)
head(biomass)
strains=unique(abs$StrainName)
strains=strains[strains%in%co2$taxa]
strains=strains[strains%in%biomass$strain]
taxon=strains[3]
abs$StrainName
abs=read.table("GrowthRate_input_raw_labiso.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
colnames(abs)
?scan
list.files()
getwd()
setwd("~/Documents/Teaching/Intro2Comp/ICB_Fall2017/Lectures/Lecture11/")
list.files()
fasta=scan(file="Lecture11.fasta",what=character())
head(fasta)
length(fasta)
i=1
grepl(">",fasta[i])
substr(fasta[i],2,nchar(fasta[i]))
seqID=substr(fasta[i],2,nchar(fasta[i]))
# answers for Lecture 11 extra practice
# 1
# load fasta file using scan()
fasta=scan(file="Lecture11.fasta",what=character())
head(fasta)
# pre-allocate matrix to store sequence information
summ=matrix(NA,length(fasta)/2,4)
# loop through lines of fasta and process each record
for(i in 1:length(fasta)){
# if-else to figure out if we have a recordID line or sequence line
if(gprel(">",fasta[i])){
summ[((i+1)/2),1]=substr(fasta[i],2,nchar(fasta[i])) # could use counter instead of complicated row calculation
}else{
seqLength=nchar(fasta[i])
numG=
numC=
if(seqLength<=14){
Tm=2*(numG+numC)+2*seqLength
}else{
Tm=-9999
}
summ[i/2,2]=seqLength
summ[i/2,3]=(numG+numC)/seqLength
summ[i/2,4]=Tm
}
}
fasta=scan(file="Lecture11.fasta",what=character())
head(fasta)
# pre-allocate matrix to store sequence information
summ=matrix(NA,length(fasta)/2,4)
# loop through lines of fasta and process each record
for(i in 1:length(fasta)){
# if-else to figure out if we have a recordID line or sequence line
if(grepl(">",fasta[i])){
summ[((i+1)/2),1]=substr(fasta[i],2,nchar(fasta[i])) # could use counter instead of complicated row calculation
}else{
seqLength=nchar(fasta[i])
numG=
numC=
if(seqLength<=14){
Tm=2*(numG+numC)+2*seqLength
}else{
Tm=-9999
}
summ[i/2,2]=seqLength
summ[i/2,3]=(numG+numC)/seqLength
summ[i/2,4]=Tm
}
}
summ
?Str_count
gregexpr("A",fasta[2])
regmatches(fasta[2], gregexpr("A",fasta[2]))
length(regmatches(fasta[2], gregexpr("A",fasta[2])))
lengths(regmatches(fasta[2], gregexpr("A",fasta[2])))
nchar(fasta[2])-nchar(gsub("A","",fasta[2]))
fasta=scan(file="Lecture11.fasta",what=character())
head(fasta)
# pre-allocate matrix to store sequence information
summ=matrix(NA,length(fasta)/2,4)
# loop through lines of fasta and process each record
for(i in 1:length(fasta)){
# if-else to figure out if we have a recordID line or sequence line
if(grepl(">",fasta[i])){
summ[((i+1)/2),1]=substr(fasta[i],2,nchar(fasta[i])) # could use counter instead of complicated row calculation
}else{
seqLength=nchar(fasta[i])
numG=nchar(fasta[i])-nchar(gsub("G","",fasta[i]))
numC=nchar(fasta[i])-nchar(gsub("C","",fasta[i]))
if(seqLength<=14){
Tm=2*(numG+numC)+2*seqLength
}else{
Tm=-9999
}
summ[i/2,2]=seqLength
summ[i/2,3]=(numG+numC)/seqLength
summ[i/2,4]=Tm
}
}
# answers for Lecture 11 extra practice
# 1
# load fasta file using scan()
fasta=scan(file="Lecture11.fasta",what=character())
head(fasta)
# pre-allocate matrix to store sequence information
summ=matrix(NA,length(fasta)/2,4)
# loop through lines of fasta and process each record
for(i in 1:length(fasta)){
# if-else to figure out if we have a recordID line or sequence line
if(grepl(">",fasta[i])){
summ[((i+1)/2),1]=substr(fasta[i],2,nchar(fasta[i])) # could use counter instead of complicated row calculation
}else{
seqLength=nchar(fasta[i])
numG=nchar(fasta[i])-nchar(gsub("G","",fasta[i]))
numC=nchar(fasta[i])-nchar(gsub("C","",fasta[i]))
if(seqLength<=14){
Tm=2*(numG+numC)+2*seqLength
}else{
Tm=-9999
}
summ[i/2,2]=seqLength
summ[i/2,3]=round((numG+numC)/seqLength*100,1)
summ[i/2,4]=Tm
}
}
summ
i=199
i=197
grepl(">",fasta[i])
i=198
fasta[i]
seqLength=nchar(fasta[i])
numG=nchar(fasta[i])-nchar(gsub("G","",fasta[i]))
numC=nchar(fasta[i])-nchar(gsub("C","",fasta[i]))
Tm=2*(numG+numC)+2*seqLength
seqLength
numG
numC
Tm
run=read.table("findRuns.txt")
run
dim(run)
z=unlist(run)
dim(z)
length(z)
z
run=unlist(run)
run
out=matrix(NA,1,2)
cur=run[1]
cur
i=2
findRuns=read.table("findRuns.txt",header=FALSE,sep="\t")
# convert data from a single-column dataframe to a vector
findRuns=unlist(findRuns)
out=NULL
cur=findRuns[1]
count=1
i=2
findRuns[i]==cur
count>1
i=3
cur=findRuns[i]
cur=findRuns[2]
i
findRuns[i]==cur
count
# create a variable out that is currently undefined
out=NULL
# I will use this variable cur to hold onto the previous number in the vector;
# this is analagous to using findRuns[i-1]
cur=findRuns[1]
# this is a counter that I use to keep track of how long a run of repeated values is;
# if there are not repeated values than this count equals 1
count=1
# loop through each entry of our vector (except the 1st one, which we set to cur above)
for(i in 2:length(findRuns)){
# test if the ith value in the vector findRuns equals the previous (stored in cur)
if(findRuns[i]==cur){
# test whether count is 1 (we aren't in the middle of a run) or >1 (in the middle of a run)
if(count==1){
# if the ith value in the vector equals the previous (stored in cur) and count is 1, we
# are at the beginning of a run and we want to store this value (we temporarily store it in 'start')
start=(i-1)
}
# we add one to count because the run continued based on the ith value of findRuns being equal to
# the previous (stored in cur)
count=count+1
# if the ith value in findRuns is not the same as the previous (stored in cur) we either are not in a run
# or we are ending a run
}else{
# if count is greater than 1 it means we were in a run and must be exiting one
if(count>1){
# add a row to 'out' that will hold the starting positions in the first column and the length
# of runs in the second column; this appends rows to out after finding and counting each run
out=rbind(out,c(start,count))
# reset count to 1 because we just exited a run
count=1
}
}
# remember cur holds the previous element in findRuns, so we need to update this after each time
# we go through the for loop
cur=findRuns[i]
}
out
findRuns
# answers for Lecture 11 extra practice
# 1
# load fasta file using scan()
fasta=scan(file="Lecture11.fasta",what=character())
head(fasta)
# pre-allocate matrix to store sequence information
summ=matrix(NA,length(fasta)/2,4)
# loop through lines of fasta and process each record
for(i in 1:length(fasta)){
# if-else to figure out if we have a recordID line or sequence line
if(grepl(">",fasta[i])){
summ[((i+1)/2),1]=substr(fasta[i],2,nchar(fasta[i])) # could use counter instead of complicated row calculation
}else{
seqLength=nchar(fasta[i])
numG=nchar(fasta[i])-nchar(gsub("G","",fasta[i]))
numC=nchar(fasta[i])-nchar(gsub("C","",fasta[i]))
if(seqLength<=14){
Tm=2*(numG+numC)+2*seqLength
}else{
Tm=-9999
}
summ[i/2,2]=seqLength
summ[i/2,3]=round((numG+numC)/seqLength*100,1)
summ[i/2,4]=Tm
}
}
out=data.frame(sequenceID=summ[,1],sequenceLength=as.numeric(summ[,2]),percentGC=as.numeric(summ[,3]),meltingTemp=as.numeric(summ[,4]))
head(out)
out
findRuns=read.table("findRuns.txt",header=FALSE,sep="\t")
# convert data from a single-column dataframe to a vector
findRuns=unlist(findRuns)
# create a variable out that is currently undefined
out=NULL
# I will use this variable cur to hold onto the previous number in the vector;
# this is analagous to using findRuns[i-1]
cur=findRuns[1]
# this is a counter that I use to keep track of how long a run of repeated values is;
# if there are not repeated values than this count equals 1
count=1
# loop through each entry of our vector (except the 1st one, which we set to cur above)
for(i in 2:length(findRuns)){
# test if the ith value in the vector findRuns equals the previous (stored in cur)
if(findRuns[i]==cur){
# test whether count is 1 (we aren't in the middle of a run) or >1 (in the middle of a run)
if(count==1){
# if the ith value in the vector equals the previous (stored in cur) and count is 1, we
# are at the beginning of a run and we want to store this value (we temporarily store it in 'start')
start=(i-1)
}
# we add one to count because the run continued based on the ith value of findRuns being equal to
# the previous (stored in cur)
count=count+1
# if the ith value in findRuns is not the same as the previous (stored in cur) we either are not in a run
# or we are ending a run
}else{
# if count is greater than 1 it means we were in a run and must be exiting one
if(count>1){
# add a row to 'out' that will hold the starting positions in the first column and the length
# of runs in the second column; this appends rows to out after finding and counting each run
out=rbind(out,c(start,count))
# reset count to 1 because we just exited a run
count=1
}
}
# remember cur holds the previous element in findRuns, so we need to update this after each time
# we go through the for loop
cur=findRuns[i]
}
# give out column names and print it
colnames(out)=c('start','length')
out
getwd()
setwd("../../Tutorials/Tutorial06")
list.files()
data=read.table("UWvMSU_1-22-13.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
dim(data)
head(data)
dim(scoring)
scoring=read.table("UWvMSU_1-22-13.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
# look at data
dim(scoring)
head(scoring)
cum_scores=matrix(NA,nrow(scoring)+1,3)
cum_scores[,1]=c(0,scoring[,1])
cum_scores
cum_scores[1,2:3]=0
colnames(cum_scores)=c("time","UW","MSU")
for(i in 1:nrow(scoring)){
if(scoring[i,2]=="UW"){
cum_scores[(i+1),2]=cum_scores[i,2]+scoring[i,3]
cum_scores[(i+1),3]=cum_scores[i,3]
}else{
cum_scores[(i+1),2]=cum_scores[i,2]
cum_scores[(i+1),3]=cum_scores[i,3]+scoring[i,3]
}
}
plot(cum_scores[,1],cum_scores[,2],lwd=3,col='red',ylim=range(cum_scores),type='l')
lines(cum_scores[,1],cum_scores[,3],lwd=3,col='darkgreen')
?sample
myNumber=sample(x=1:100,size=1)
myNumber
myNumber=sample(x=1:100,size=1)
myNumber
# randomly draw an integer between 1 and 100
myNumber=sample(x=1:100,size=1)
# create a while loop that runs until we indicate that the guesser got it correct
while(correct==0){
# prompt the user for a guess
guess=readline(prompt="Guess:")
if(guess<myNumber){
print("Higher")
}else if(guess>myNumber){
print("Lower")
}else{
print("Correct!")
correct=1
}
}
myNumber=sample(x=1:100,size=1)
# create a while loop that runs until we indicate that the guesser got it correct
correct=0
while(correct==0){
# prompt the user for a guess
guess=readline(prompt="Guess:")
if(guess<myNumber){
print("Higher")
}else if(guess>myNumber){
print("Lower")
}else{
print("Correct!")
correct=1
}
}
myNumber=sample(x=1:100,size=1)
# create a while loop that runs until we indicate that the guesser got it correct
correct=0
while(correct==0){
# prompt the user for a guess
guess=readline(prompt="Guess:")
if(guess<myNumber){
print("Higher")
}else if(guess>myNumber){
print("Lower")
}else{
print("Correct!")
correct=1
}
}
# Exercise 6 answers
# SEJ
# 9-26-2017
# 1 - scoring plot
# load table of scoring
scoring=read.table("UWvMSU_1-22-13.txt",header=TRUE,sep="\t",stringsAsFactors=FALSE)
# look at data
dim(scoring)
head(scoring)
# preallocating matrix to store cumulative scores
cum_scores=matrix(NA,nrow(scoring)+1,3)
cum_scores[,1]=c(0,scoring[,1])
cum_scores[1,2:3]=0
colnames(cum_scores)=c("time","UW","MSU")
# looping through individual scoring events
for(i in 1:nrow(scoring)){
if(scoring[i,2]=="UW"){
cum_scores[(i+1),2]=cum_scores[i,2]+scoring[i,3]
cum_scores[(i+1),3]=cum_scores[i,3]
}else{
cum_scores[(i+1),2]=cum_scores[i,2]
cum_scores[(i+1),3]=cum_scores[i,3]+scoring[i,3]
}
}
# plotting results
plot(cum_scores[,1],cum_scores[,2],lwd=3,col='red',ylim=range(cum_scores),type='l')
lines(cum_scores[,1],cum_scores[,3],lwd=3,col='darkgreen')
# 2 - guess my number
# randomly draw an integer between 1 and 100
myNumber=sample(x=1:100,size=1)
# create a while loop that runs until we indicate that the guesser got it correct
correct=0
while(correct==0){
# prompt the user for a guess
guess=readline(prompt="Guess:")
if(guess<myNumber){
print("Higher")
}else if(guess>myNumber){
print("Lower")
}else{
print("Correct!")
correct=1
}
}
wages=read.table("wages.csv",header=TRUE,sep=",",stringsAsFactors=FALSE)
getwd()
setwd("../../Lectures/Lecture11/")
wages=read.table("wages.csv",header=TRUE,sep=",",stringsAsFactors=FALSE)
dim(wages)
wages=read.table("wages.csv",header=TRUE,sep=",",stringsAsFactors=FALSE)
# create variables to store sums
femaleSum=0
maleSum=0
for(i in 1:nrow(wages)){
if(wages$gender[i]=="female"){
femaleSum=femaleSum+wages$wage[i]
}else{
maleSum=maleSum+wages$wage[i]
}
}
femaleSum
maleSum
sum(wages$gender=="female")
sum(wages$gender=="male")
